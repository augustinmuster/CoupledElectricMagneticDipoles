var documenterSearchIndex = {"docs":
[{"location":"geometries/#Geometries-library","page":"Geometries","title":"Geometries library","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"Geometries is a small modules allowing to discretize primitives in small cubes, that can be later used in the DDA. The two primitives that are proposed are a sphere and a cube. The description of the two functions are given in the next section. Note that the discretization of the sphere implements anti-aliasing (see Wikipedia page for anti-aliasing or the polystyrene spherre example).","category":"page"},{"location":"geometries/#Functions-Documentation","page":"Geometries","title":"Functions Documentation","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_sphere","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","text":"discretize_sphere(a,N,N_sub=10)\n\nDiscretize the volume of a sphere of radius a in small cubes of edge dx=2*a/N. N_sub is a parameter to set the anti-aliasing accuracy of the discretisation. By default set to 10. If N_d is the obtained number of cubes, the output is a N times 4 array containing the 3D position of the centers of the cubes and their filling fraction. Returns as well the size of the edge of the cube.\n\n\n\n\n\n","category":"function"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_cube(L,N)","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube-Tuple{Any, Any}","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube","text":"discretize_cube(L,N)\n\nDiscretize the volume of a cube of edge L in small cubes of edge dx=L/N. If N_d is the obtained number of cubes, the output is a N times 4 array containing the 3D position of the centers of the cubes and their filling fraction (i.e. 1). Returns as well the size of the edge of the cube.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Post-Processing","page":"PostProcessing","title":"Post Processing","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The PostProcessing modules allows you to process the results of a CEMD calculation. Mostly for:","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"Computing cross sections.\nComputing scattered fields.\nComputing local density of states (LDOS).","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The list of functions and a description of how to use them is given in the following section.","category":"page"},{"location":"postprocessing/#Functions-List-and-Documentation","page":"PostProcessing","title":"Functions List and Documentation","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment(alpha,phi_inc)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment-Tuple{Any, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment","text":"compute_dipole_moment(alpha,phi_inc)\n\nComputes the dipole moment (magnetic or electric) of a dipole with polarizability alpha under an incident field phi_inc. alpha can be:\n\na complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e(knorm,kr,e_inc,alpha,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e","text":"compute_cross_sections_e(knorm,kr,e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion ans scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric dipoles. Notes that it sould follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nInputs \n\nknorm: wavenumber\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident fields E_inc on every dipole.\nalpha_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the input field E_0 at each of the dipoles positions.\nexplicit_scattering: boolean that says wether to compute scttering cross section explicitely (formula) or to deduce it from the optical theorem. By default set to true.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing in order: extinction, absorption and scattering cross section.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion ans scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric dipoles. Notes that it sould follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nInputs \n\nknorm: wavenumber\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\ne_inc: 2D complex array of size Ntimes 6 containing the incident fields E_inc on every dipole.\nalpha_e_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarisability of each dipoles. See the Alphas module for accepted formats.\ninput_field: input field on each dipole (Ntimes 6) array.\nexplicit_scattering: boolean that says wether to compute scttering cross section explicitely (formula) or to deduce it from the optical theorem. By default set to true.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing in order: extinction, absorption and scattering cross section.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e(kr, alpha_e_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e","text":"function field_sca_e(kr, alpha_e_dl, e_inc, krf)\n\nIt computes the scattered field from the ensemble of dipoles.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 with the incident field E_inc in the dipoles.\nkrf: 2D float array of size Nftimes 3 containing the dimentionless positions kvecr_f where the scattered field is calculated.\n\n#Outputs\n\nfield_r: 2D complex array of size Nftimes 3 with the field scattered by the dipoles at every kvecr_f.\n\nEquation\n\nmathbfE_sca(mathbfr) = k^2G(mathbfrmathbfbarr_N) alpha(mathbfbarr_N) mathbfE_inc(mathbfbarr_N) = k^2 G(mathbfrmathbfbarr_N) alpha(mathbfbarr_N) D(mathbfbarr_N) E_0\n\n\\r = r0 \\bar{r}}N = pos \\alphagg(\\mathbf{\\bar{r}}N) = alpha \\GG(\\r,\\mathbf{\\bar{r}}N) = `Gtensor\\E_{inc}(\\mathbf{\\bar{r}}_N) =E_inc`\n\n\\E{sca}(\\r) = `fieldr`\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf)\n\nIt computes the scattered field from the ensemble of dipoles.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_e_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarisability of each dipoles. See the Alphas module for accepted formats.\ne_inc: 2D complex array of size Ntimes 6 with the incident field phi_inc=(E_incH_inc) on the dipoles.\nkrf: 2D float array of size Nftimes 3 containing the dimentionless positions kvecr_f where the scattered field is calculated.\n\n#Outputs\n\nfield_r: 2D complex array of size Nftimes 6 with the field scattered by the dipoles at every kvecr_f.\n\nEquation\n\nmathbfE_sca(mathbfr) = k^2G(mathbfrmathbfbarr_N) alpha(mathbfbarr_N) mathbfE_inc(mathbfbarr_N) = k^2 G(mathbfrmathbfbarr_N) alpha(mathbfbarr_N) D(mathbfbarr_N) E_0\n\n\\r = r0 \\bar{r}}N = pos \\alphagg(\\mathbf{\\bar{r}}N) = alpha \\GG(\\r,\\mathbf{\\bar{r}}N) = `Gtensor\\E_{inc}(\\mathbf{\\bar{r}}_N) =E_inc`\n\n\\E{sca}(\\r) = `fieldr`\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_dl, e_inc, krf)\n\nIt computes the scattered field from the ensemble of dipoles.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_dl: complex dimensionless electric and magnetic polarisability of each dipoles. See the Alphas module for accepted formats.\ne_inc: 2D complex array of size Ntimes 6 with the incident field E_inc on the dipoles.\nkrf: 2D float array of size Nftimes 3 containing the dimentionless positions kvecr_f where the scattered field is calculated.\n\n#Outputs\n\nfield_r: 2D complex array of size Nftimes 6 with the field scattered by the dipoles at every kvecr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e","text":"ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing)\n\nIt Computes local density of states (LDOS) by the imaginary part of the returning field.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_e_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\nAinv: (inverse) DDA matrix I - G*alpha^(-1).\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kvecr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 3 with the desired dipole moment of the dipole.  \n\n#Outputs\n\nLDOS: float array with the LDOS.\n\nEquation\n\nmathrmLDOS(mathbfbarr_Nr_0) = 1 + dfrac1bm mu^2 dfrac6pik^3 Imleftbm mu^* cdot k^2GG(r_0mathbfbarr_N) alphagg(mathbfbarr_N) DD(mathbfbarr_N) k^2 GG(mathbfbarr_N r_0) bm mu  right\n\n\\alphagg(\\mathbf{\\bar{r}}N) = alpha \\DD(\\mathbf{\\bar{r}}N) = Ainv = [I - k^2Galpha]^(-1) \\bar{r}}N = pos \\r0 = rd \\dfrac{1}{\\epsilon0\\epsilon} \\bm \\mu = `dipo` (the pre-factor -\\dfrac{1}{\\epsilon_0\\epsilon}- dessapears after normalization)\n\nk^2\\GG(\\r0,\\mathbf{\\bar{r}}N) \\alphagg(\\mathbf{\\bar{r}}N) \\DD(\\mathbf{\\bar{r}}N) k^2 \\GG(\\mathbf{\\bar{r}}N, \\r0) \\bm \\mu = field_r \\DD(\\mathbf{\\bar{r}}N) k^2 \\GG(\\mathbf{\\bar{r}}N, \\r0) \\bm \\mu = `Einc`\n\n\\mathrm{LDOS}(\\mathbf{\\bar{r}}N,\\r0) = LDOS\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing)\n\nIt Computes local density of states (LDOS) by the imaginary part of the returning field.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_e_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarisability of each dipoles. See the Alphas module for accepted formats.\nAinv: (inverse) DDA matrix I - G*alpha^(-1).\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kvecr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 6 with the desired dipole moment of the dipole.  \n\n#Outputs\n\nLDOS: float array with the LDOS.\n\nEquation\n\nmathrmLDOS(mathbfbarr_Nr_0) = 1 + dfrac1bm mu^2 dfrac6pik^3 Imleftbm mu^* cdot k^2GG(r_0mathbfbarr_N) alphagg(mathbfbarr_N) DD(mathbfbarr_N) k^2 GG(mathbfbarr_N r_0) bm mu  right\n\n\\alphagg(\\mathbf{\\bar{r}}N) = alpha \\DD(\\mathbf{\\bar{r}}N) = Ainv = [I - k^2Galpha]^(-1) \\bar{r}}N = pos \\r0 = rd \\dfrac{1}{\\epsilon0\\epsilon} \\bm \\mu = `dipo` (the pre-factor -\\dfrac{1}{\\epsilon_0\\epsilon}- dessapears after normalization)\n\nk^2\\GG(\\r0,\\mathbf{\\bar{r}}N) \\alphagg(\\mathbf{\\bar{r}}N) \\DD(\\mathbf{\\bar{r}}N) k^2 \\GG(\\mathbf{\\bar{r}}N, \\r0) \\bm \\mu = field_r \\DD(\\mathbf{\\bar{r}}N) k^2 \\GG(\\mathbf{\\bar{r}}N, \\r0) \\bm \\mu = `Einc`\n\n\\mathrm{LDOS}(\\mathbf{\\bar{r}}N,\\r0) = LDOS\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing)\n\nIt Computes local density of states (LDOS) by the imaginary part of the returning field.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_dl: complex dimensionless electric and magnetic polarisability of each dipoles. See the Alphas module for accepted formats.\nAinv: (inverse) DDA matrix I - G*alpha^(-1).\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kvecr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 6 with the desired dipole moment of the dipole.  \n\n#Outputs\n\nLDOS: float array with the LDOS.\n\nEquation\n\nmathrmLDOS(mathbfbarr_Nr_0) = 1 + dfrac1bm mu^2 dfrac6pik^3 Imleftbm mu^* cdot k^2GG(r_0mathbfbarr_N) alphagg(mathbfbarr_N) DD(mathbfbarr_N) k^2 GG(mathbfbarr_N r_0) bm mu  right\n\n\\alphagg(\\mathbf{\\bar{r}}N) = alpha \\DD(\\mathbf{\\bar{r}}N) = Ainv = [I - k^2Galpha]^(-1) \\bar{r}}N = pos \\r0 = rd \\dfrac{1}{\\epsilon0\\epsilon} \\bm \\mu = `dipo` (the pre-factor -\\dfrac{1}{\\epsilon_0\\epsilon}- dessapears after normalization)\n\nk^2\\GG(\\r0,\\mathbf{\\bar{r}}N) \\alphagg(\\mathbf{\\bar{r}}N) \\DD(\\mathbf{\\bar{r}}N) k^2 \\GG(\\mathbf{\\bar{r}}N, \\r0) \\bm \\mu = field_r \\DD(\\mathbf{\\bar{r}}N) k^2 \\GG(\\mathbf{\\bar{r}}N, \\r0) \\bm \\mu = `Einc`\n\n\\mathrm{LDOS}(\\mathbf{\\bar{r}}N,\\r0) = LDOS\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#DDA-Core-Functionalities","page":"DDACore","title":"DDA Core Functionalities","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"DDACore is the modules allowing to solve CEMD problems (see supplemetary informations in the \"Theory\" tab for definition of the problem). The problems can be solved either on the CPU (in parrallel with LAPACK) or on the GPU (With CUDA). The list of functions and how to use them is in the next section. ","category":"page"},{"location":"ddacore/#Functions-List-and-Documentation","page":"DDACore","title":"Functions List and Documentation","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e","text":"solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations under a given input field vecE_0, i.e.\n\nvecE_i=vecE_0(vecr_i)+sum^N_jneq iG_e(vecr_ivecr_j)alpha_jvecE_j\n\n\nfor a group of N only electric dipoles and returns the incident fields on each of the dipoles. \n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr of each dipole.\nalpha_e_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formattings.\ninput_field: 2D complex array of size Ntimes 3 containing the input field E_0 at each of the dipoles positions.\nsolver: string that contains the name of the solver that need to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output informations to the standard output during running or not. By default set to true.\n\n#Outputs\n\ne_inc: 2D complex array of size Ntimes 3 containing the incident fields E_inc on every dipole.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations with dimensionless inputs under a given input field, i.e.\n\nvecE_i  =vecE_0left(vecr_iright)+sum_jneq iG_Eleft(vecr_ivecr_jright)alpha_E^(j)vecE_j+iG_Mleft(vecr_ivecr_jright)alpha_M^(j)vecH_j\n\nvecH_i  =vecH_0left(vecr_iright)+sum_jneq i-iG_Mleft(vecr_ivecr_jright)alpha_E^(j)vecE_j+G_Eleft(vecr_ivecr_jright)alpha_M^(j)vecH_j\n\nfor a group of N electric and magnetic dipoles and return the polarisations of every particle and incident fields on every particle.\n\n#Arguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless positions kvecr of all the dipoles.\nalpha_e_dl: complex dimensionless electric polarisability of each dipoles. See the Alphas module for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarisability of each dipoles. See the Alphas module for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the input field phi_0=(E_0H_0) at each of the dipoles positions.\nsolver:string that contains the name of the solver that need to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\n#Outputs\n\ne_inc: 2D complex array of size Ntimes 6 containing the incident fields phi_inc=(E_incH_inc) on every dipole.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"function solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nSimilar to solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true), but the polarisabilities are 6times 6 complex tensors taking into account both electrric and magnetic behaviour of the particles and its optical activity. alpha is a 3D complex array of size Ntimes 6times 6containing the dimesnionless polarisability of each particle.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_system(A,b,solver,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_system-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_system","text":" solve_system(A,b,solver,verbose)\n\nSolves a system of equations of the type Ax=b where matrix is A and vector is b using the method solver and returns x. x can be a 1D column vector or a 2D matrix. In this second case, the system is going to solve each column of the matrix as a different problem (without re-inverting A). The solver flag can be set to\n\nCPU: In this case, the system is solved using LAPACK on the CPU.\nGPU: In this case, the system is solved using CUSOLVE on the GPU (if available).\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e(kr,alpha_e_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e","text":" load_dda_matrix_e(kr,alpha_e_dl,verbose)\n\nBuilds the electric only DDA matrix A=I-Galpha with dimensionless postitions kr (2D array of size Nx3) and dimensionless polarisabilities alpha_e_dl (see foramt rules in Alphas module). Returns 3Ntimes 3N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)\n\nBuilds the electric and magnetic DDA matrix A=I-Galpha with dimensionless postitions kr (2D array of size Ntimes 3) and dimensionless electric and magnetic polarisabilities alpha_e_dl and  alpha_m_dl (see format rules in the Alphas module). Return 6Ntimes 6N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_tensor,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_tensor,verbose)\n\nBuilds the electric and magnetic DDA matrix A=I-Galpha with dimensionless postitions kr (two dimensional arrays of size Ntimes 3) and dimensionless polarisability alpha_tensor (a three-dimensional complex array of size Ntimes 6times 6containing the polarisability 6times 6 tensor of each dipole). Return 6Ntimes 6N complex DDA matrix\n\n\n\n\n\n","category":"method"},{"location":"alphas/#Polarisabilities","page":"Alphas","title":"Polarisabilities","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"Alphas is a module to load polarizabilities. In this module, you will find functions to compute electric and magnetic polarizabilities of several objects. The modules also contains some functions to renormalize polarizabilities and to manage  the multiple formats of the polarizabilities (dispatch). The list of functions as well as how to use them is given below. ","category":"page"},{"location":"alphas/#Format-of-the-polarizabilities-in-the-DDACore-and-PostProcessing-functions","page":"Alphas","title":"Format of the polarizabilities in the DDACore and PostProcessing functions","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"The functions of the DDACore and PostProcessing modules come with an automatic dispatch of the format of the polarizability. If we have N dipoles, it can be:","category":"page"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"a complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6","category":"page"},{"location":"alphas/#Functions-Documentation","page":"Alphas","title":"Functions Documentation","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped(lx,ly,lz,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped-NTuple{5, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped","text":"alpha0_parallelepiped(lx,ly,lz,eps,eps_h)\n\nComputes the quasistatic polarizability tensor of a parallelepiped of dimensions lx,ly,lz and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a 3times 3 float matrix with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_sphere(a,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere","text":"alpha0_sphere(a,eps,eps_h)\n\nComputes the quasistatic polarizability of a sphere of radiusa and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a float matrix with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_volume(V,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume","text":"alpha0_volume(a,eps,eps_h)\n\nComputes the quasistatic polarizability of any object with volume V and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a float matrix with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_radiative(alpha0,knorm)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative","text":"alpha_radiative(alpha0,knorm)\n\nApplies the radiative correction to the polarizability tensor or scalar alpha0, with units of voume. Outputs a (3x3) complex dimensionless scalar or tensor computed as follow:\n\nalpha=frack^34pileft(alpha_0^-1-ifrack^36piright)^-1\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie(knorm,a,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie-NTuple{4, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie","text":"alpha_e_m_mie(vac_knorm,a,eps,eps_h)\n\nComputes the electric and magnetic polarisabilitie from the mie coefficients a_1 and  b_1 of a particle of dielectric constant eps and radius a in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium It outputs two dimensionless scalars which are computed with:\n\nalpha_E =frack^3tildealpha_E4pi=ifrac32a_1 alpha_M =frack^3tildealpha_M4pi=ifrac32b_1\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e(alpha_e_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e","text":"dispatch_e(alpha_e_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuply a Green function for the polarizability of particle i\n\nImputs\n\nalpha_e_dl = electric polarizability\n\nOutputs\n\nalp_e = iterable electric polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuply a Green function for the polarizability of particle i.\n\n#Arguments\n\nalpha_e_dl: = electric polarizability\nalpha_m_dl: = magnetic polarizability\n\n#Outputs\n\nalp_e: = iterable electric polarizability\nalp_m: = iterable magnetic polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuply a Green function for the polarizability of particle i\n\n#Arguments\n\nalpha_dl: = polarizability\n\n#Outputs\n\nalp: = iterable polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.renorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha","text":"renorm_alpha(knorm,alpha)\n\nRenormalizes any polarizability with units of volume in a dimensionless polarizability by multiplying by k^34pi.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.denorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha","text":"denorm_alpha(knorm,alpha)\n\nDenormalizes any dimensionless polarizability in a polarizability with units of volume by multiplying by 4pi k^3.\n\n\n\n\n\n","category":"method"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"\n<embed type=\"application/pdf\" src=\"../assets/CoupledElectricMagneticDipoles.pdf\" width=\"1000\" height=\"100%\" </embed>\n\n<p>This browser does not support PDFs? Please download the PDF to view it: <a href=\"../assets/CoupledElectricMagneticDipoles.pdf\">Download PDF</a>.</p>","category":"page"},{"location":"example_PS_sphere/#Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere","page":"PS Sphere","title":"Total and Differential Scattering Cross Sections of a Polystyrene Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This example aims to teach the user how to use CEMD.jl in only electric mode. For this we will compute the total and differential scattering cross section of a polystyrene (PS) sphere with a radius of 500nm in water. We will then compare it with mie theory.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Be careful: using the electric DDA a for solving this type of problems is not optimal at all (way to slow and not accurate). The sizes and refractive indices used in this example make the problem converge reasonably well (see last section) and is then a nice figure of merit for this software. If you need to solve the light scattering of a sphere, it is better to use directly Mie theory. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you don't now what a DDA problem is, please first have a look to the theory part.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you want to run this example, copy it or download it on the github (example_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"julia example_PS_sphere.jl\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you can, it is recommanded to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra and Lebedev are used to perform integrals on the surface of a sphere (Lebedev.jl).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\nusing Lebedev\nusing LinearAlgebra\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_PS_sphere/#Discretizing-the-Sphere","page":"PS Sphere","title":"Discretizing the Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We then need to start modelizing our particle in water. For, this we start by defining the parameters of the simulation. PS has a refractive index of 1.59 (we consider no absorption, so no imaginary part). For water, it is 1.33. We can then set the dielectric constant of the particle eps and of the medium eps_h using epsilon=n^2. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"##################### Parameters ########################################\n#radius of the sphere\na=250e-9\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n#number of wavelengths to compute\nN_lambda=10\nlambda_min=1000e-9\nlambda_max=1100e-9\n#wavelengths to compute\nlambdas0=LinRange(1000e-9,1100e-9,N_lambda)\nlambdas=lambdas0/sqrt(eps_h)\n##########################################################################","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"lambdas0 are the wavelength for which we want to compute the scattering cross section (here between 1000 and 1100nm). We directly computes the wavelength in medium by dividing by the refractive index. Note that we always use the wavenumber in the medium in the software.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then dicretize the sphere in small cubes using Geometries.discretize_sphere. The first parameter is the radius of the sphere and the second is the number of cubes to place in the diameter of the sphere (it will set the total number of cubes of the discretized sphere).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If N is the number of cubes in the discretized sphere, this function returns a Nx4 array latt, that contains the coordinates of the center of each cube, as well as its filling fraction (If the cube is in the bulk, the filling fractions is 1. If it is on the surface, the filling fraction can be smaller than 1, depending on volume fraction of the sphere really inside the sphere.). It also retruns dx, which is the length of the edges of all the cubes.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here for instance, the number of cubes in the discretized sphere is N=720.","category":"page"},{"location":"example_PS_sphere/#Computing-the-Polarizabilities","page":"PS Sphere","title":"Computing the Polarizabilities","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Now that the sphere is discretized, we need to assign to every cube a polarizability. This polarizability is wavelength dependant and then we nee to create an array to store teh results of the cross section claculations for each wavelength. For this, we use:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"res=zeros(Float64,N_lambda,3)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then open a loop and computes the polarizability of each cube as follows:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#solves DDA problem for each wavelength\nfor i=1:N_lambda\n    #wavenumber in medium\n    knorm=2*pi/lambdas[i]\n    #computes polarizability for each dipoles using effective dielectric constant \n    alpha=zeros(ComplexF64,n,3,3)\n    for j=1:n\n        eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n        alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\n    end","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here, we first compute the wavenumber in the medium and then, using the second loop, assign a polarizability to each cube. Alphas.alpha0_parallelepiped computes the quasistatic polarizability tensor (a 3x3 complex matrix with units of volume) of a cube. Here, we use eps_eff, which is the filling fraction-ponderated mean between the dielectric constant inside and ouside the medium. Then, we need to apply the radiative correction to the polarizability using Alphas.alpha_radiative. This last function also renormalize the polarizability from units of volume to no dimensions. We need this because the functions to solve the DDA problem require dimensionless inputs (see the home page and the theory part for more information!).","category":"page"},{"location":"example_PS_sphere/#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections","page":"PS Sphere","title":"Solving the DDA Problem and Computing the Total Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Before solving the DDA, problem, we need to choose an input field. We will take a x-polarized plane wave propagating along the positive z axis. For this, we use inputFields.plane_wave_e. This functions takes the dimensionless positions kr of the center of the cubes (i.e. the wavenumber times the coordinates array) and outputs a Nx3 array that reprensent the input field on each of the dipoles.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes input_field, a x-polarized plane-wave propagating along z\n    input_field=InputFields.plane_wave_e(knorm*latt[:,1:3])","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can now solve the DDA problem between all the dipoles using DDACore.solve_DDA_e:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #solves DDA\n    e_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"The solver is set to \"CPU\", that means that the system of linear equations is going to be solved using the CPU and LAPACK, called from julia. This outputs a Nx3 complex array containing the incident field on each dipole. This incident field can the be used to compute the extinction, absorption and scattering total cross sections (sigma_ext sigma_abs sigma_sca) by calling PostProcessing.compute_cross_sections_e.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes cross section and save it in folder\n    res[i,1:end]=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\nend","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This function is just returning sigma_ext sigma_abs sigma_sca in a float array. This results is directly saved in res, that we created before.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It is now possible to plot the normalized scattering cross section (Q_sca=sigma_scapi a^2) as a function of the vacuum wavelength divided by the radius lambda_0 a. To check that the result we obtain is correct, we compare with Mie theory (using the MieCoeff module). We also plot the error (Q_ext-Q_abs-Q_abs)Q_ext to check tha t the optical theorem, i.e. sigma_ext=sigma_abs+sigma_sca is well fulfilled. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#scattering cross section from the Mie theory\nres_mie=MieCoeff.mie_scattering_cross_section.(2 .*pi./lambdas,a,eps,eps_h;cutoff=50)\n\n#plotting the cross sections using matplotlib\nfig1,ax1=plt.subplots(2,sharex=true)\n#sets axis labels\nax1[1].set_ylabel(L\"Q_{sca}\")\nax1[2].set_ylabel(L\"(Q_{ext}-Q_{abs}-Q_{abs})/Q_{ext}\")\nax1[2].set_xlabel(L\"\\lambda_0/a\")\n#plot\ncst=pi*a^2\nax1[1].plot(lambdas0./a,res[:,3]./cst,color=\"black\",label=\"DDA, N=\"*string(n),marker=\"o\")\nax1[1].plot(lambdas0./a,res_mie./cst,color=\"red\",label=\"Mie\",marker=\"o\")\nax1[2].plot(lambdas0./a,(res[:,1].-res[:,2].-res[:,3])./res[:,1],color=\"black\",marker=\"o\")\n#legend and save\nax1[1].legend()\nplt.tight_layout()\nfig1.savefig(\"Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This is what we get:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We see that the DDA cross section is not exactly the same that the Mie one and that the energy is correctly conserved.. For more information, a small convergence study is shown in the last section of this example (without code).","category":"page"},{"location":"example_PS_sphere/#Computing-the-Differential-Scattering-Cross-Sections","page":"PS Sphere","title":"Computing the Differential Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"In this part of the example, we want to compute the differential scattering cross section in the y-z plane of the same sphere (we fix here the wavelength to be lambdas[1], i.e. 1000nm in vacuum). To start, we just solve the DDA problem and computes cross sections as we did previously.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes polarizability for each dipoles using effective dielectric constant \nknorm=2*pi/lambdas[1]\nalpha=zeros(ComplexF64,n,3,3)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    global  alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\nend\n\n#computes input_field, a x-polarized plane-wave propagating along z\ninput_field=InputFields.plane_wave_e(knorm*latt[:,1:3])\n#solves DDA\ne_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")\n#computes cross section\ncs=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Then, we define a array of angle thetas in order to generate a uniform sampling ur of the units vectors in the y-z plane.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#sampling direction an plotting \nthetas=LinRange(0,2*pi,100)\nur=zeros(100,3)\nur[:,3]=cos.(thetas)\nur[:,2]=sin.(thetas)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"using this array of directions, we can compute the differential cross section in all of these directions using PostProcessing.diff_scattering_cross_section_e. This takes the same positional arguments as PostProcessing.compute_cross_sections_e, but just adding the array of directions. It outputs an array containing the differential scattering cross section in all the directions contained in ur.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes differential cross section\nres=PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,ur)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can plot it with a radial projection. This time again, we plot the normalized scattering cross section.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#plotting\nfig2=plt.figure()\nax2 = fig2.add_subplot(projection=\"polar\")\nax2.set_title(L\"log(d Q_{sca}/ d \\Omega)\")\nax2.plot(thetas,log10.(res/pi/(a^2)),label=\"y-z plane\")\nfig2.savefig(\"diff_Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/diff_Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"On this plot, the input wave is coming from the left side. We see that most of the light is forward scattered. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"For a sanity check, we can try to integrate the differential scattering cross section on the unit sphere using Lebedev.jl and compare with the total scattering cross section. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#Compare total scattering cross section and integral of the differential one\nx,y,z,w = lebedev_by_order(13)\ncsca_int=4 * pi * dot(w,PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,[x y z]))\nprintln(cs[3],\" : \",csca_int)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It outputs","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"5.004200684958882e-14 : 5.0042006849097616e-14\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"showing, that they are the same.","category":"page"},{"location":"example_PS_sphere/#A-Note-on-Convergence","page":"PS Sphere","title":"A Note on Convergence","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"As seen in the previous sections, the scattering cross section obtained with N=720 cubes/dipoles don't match perfectly with the mie solution (a bit more than 1%). But what happens if we change the number of cubes? We repeated the calculations of the total scattering cross section but with several number of dipoles (from 117 to 9549). Here are the results: ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/test_conv.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"What we see is that the error starts to be way smaller for numbers of dipoles bigger than 2295. The example of the PS sphere works quite well, but be careful, this doesn't mean that it will converge like that for every types of spheres. If you want to do that with another sphere made of another material or another object, check the convergence!. Recall also that DDA is not the best method to solve light scattering problems by a sphere. If you don't really need it, prefer to use Mie Theory.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"","category":"page"},{"location":"green/#Green-Tensors","page":"GreenTensors","title":"Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"GreenTensors is aimed to compute the electric and magnetic green tensors renormalized or not. The list of functions and its documentations is below.","category":"page"},{"location":"green/#Functions-Documentation","page":"GreenTensors","title":"Functions Documentation","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_e","text":"G_e(r1,r2,knorm)\n\nCompute the electric green tensor between two position  r1 and r2 with wavenumber knorm. The output is a 3x3 complex matrix. The electric green tensor (with units [1/m]) is defined as:\n\ntildeG_e=left(vecr_1vecr_2kright)=frace^ikr4 pi rleft(frac(kr)^2+ikr-1(kr)^2I+frac-(kr)^2-3ikr+3(kr)^2vecu_rotimesvecu_rright)\n\nwith\n\nr=r_1-r_2 vecu_r=left(r_1-r_2right)r\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_m","text":"G_m(r1,r2,knorm)\n\nCompute the magnetic green tensor between two position  r1 and r2 with wavenumber knorm. The output is a 3x3 complex matrix. The magnetic green tensor (with units [1/m^2]) is defined as:\n\ntildeG_m=left(vecr_1vecr_2kright)=frace^ikr4 pi rkleft(fracikr-1ikrright)vecu_r\n\nwith\n\nr=r_1-r_2 vecu_r=left(r_1-r_2right)r\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","text":"G_e_renorm(kr1,kr2)\n\nCompute the electric green tensor in renormalized units (see Home page) between two position multiplied by the wave number kr1 and kr2 (->dimensionless input). The output is a 3x3 complex matrix. The renormalized electric green tensor (with units [1]) is defined as:\n\nG_e=frac4*piktildeG_e\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","text":"G_m_renorm(kr1,kr2)\n\nCompute the magnetic green tensor in renormalized units (see Home page) between two position multiplied by the wave number kr1 and kr2 (->dimensionless input). The output isd a 3x3 complex matrix. The renormalized magnetic green tensor (with units [1]) is defined as:\n\nG_m=frac4*pik^2tildeG_m\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em","text":"G_em(r1,r2,k)\n\nCompute the electric and magnetic green tensor between two position r1 and r2 (r2 the origin and r1 the observation) . The output are two 3x3 complex matrix. The electric green tensor (with unit of [1/m]) is defined as:\n\ntildeG_e=left(vecr_1vecr_2kright)=frace^ikr4 pi rleft(frac(kr)^2+ikr-1(kr)^2I+frac-(kr)^2-3ikr+3(kr)^2vecu_rotimesvecu_rright)\n\nThe magnetic green tensor (with unit of [1/m]) is defined as:\n\ntildeG_mk=left(vecr_1vecr_2kright)=frace^ikr4 pi rleft(fracikr-1ikrright)vecu_r\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","text":"G_em_renorm(kr1,kr2)\n\nCompute the renormalized electric and magnetic green tensors between two position r1 and r2, where the imputs are the positions multiplied by the wave number kr1 and kr2 (->dimensionless input). The output are two 3x3 complex matrix. The electric green tensor (with unit of [1]) is defined as:\n\nG_e=frac4*piktildeG_e\n\nThe magnetic green tensor (with unit of [1]) is defined as:\n\nG_m=frac4*pik^2tildeG_m\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e","text":"dxG_e(r1,r2,knorm)\n\nCompute the derivative electric green tensor (defined in G_e(r1,r2,knorm)) regarding the x component of r1 between two position  r1 and r2 with wavenumber knorm. The output isd a 3x3 complex matrix with units [1/m^2]\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e","text":"dyG_e(r1,r2,knorm)\n\nCompute the derivative electric green tensor (defined in G_e(r1,r2,knorm)) regarding the y component of r1 between two position  r1 and r2 with wavenumber knorm. The output isd a 3x3 complex matrix with units [1/m^2]\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e","text":"dzG_e(r1,r2,knorm)\n\nCompute the derivativeelectric green tensor (defined in G_e(r1,r2,knorm)) regarding the z component of r1 between two position  r1 and r2 with wavenumber knorm. The output isd a 3x3 complex matrix with units [1/m^2]\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m","text":"dxG_m(r1,r2,knorm)\n\nCompute the derivative magnetic green tensor (defined in G_m(r1,r2,knorm)) regarding the x component of r1 between two position  r1 and r2 with wavenumber knorm. The output isd a 3x3 complex matrix with units [1/m^3]\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m","text":"dyG_m(r1,r2,knorm)\n\nCompute the derivative magnetic green tensor (defined in G_m(r1,r2,knorm)) regarding the y component of r1 between two position  r1 and r2 with wavenumber knorm. The output isd a 3x3 complex matrix with units [1/m^3]\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m","text":"dzG_m(r1,r2,knorm)\n\nCompute the derivative magnetic green tensor (defined in G_m(r1,r2,knorm)) regarding the z component of r1 between two position  r1 and r2 with wavenumber knorm. The output isd a 3x3 complex matrix with units [1/m^3]\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_em","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em","text":"dxG_em(r1,r2,knorm)\n\nCompute the derivative green tensor (defined in Ge(r1,r2,knorm) and Gm(r1,r2,knorm)/knorm) regarding the x component of r1 between two position  r1 and r2 with wavenumber knorm. The output are two 3x3 complex matrix (with units of [1/m^2]).\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_em","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em","text":"dyG_em(r1,r2,knorm)\n\nCompute the derivative green tensor (defined in Ge(r1,r2,knorm) and Gm(r1,r2,knorm)/knorm) regarding the y component of r1 between two position  r1 and r2 with wavenumber knorm. The output are two 3x3 complex matrix (with units of [1/m^2]).\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_em","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em","text":"dzG_em(r1,r2,knorm)\n\nCompute the derivative green tensor (defined in Ge(r1,r2,knorm) and Gm(r1,r2,knorm)/knorm) regarding the x component of r1 between two position  r1 and r2 with wavenumber knorm. The output are two 3x3 complex matrix (with units of [1/m^2]).\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.Sigma","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.Sigma","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.Sigma","text":"Sigma(n)\n\nSigma represent the base-change-matrix [E, ZH] to [E, iZH]\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Input-Fields","page":"InputFields","title":"Input Fields","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"This module is aimed to compute the electric and magnetic green tensors for the two system of units.","category":"page"},{"location":"input_fields/#Functions-Documentation","page":"InputFields","title":"Functions Documentation","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","text":"plane_wave_e(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes a simple plane with dimensionless input evaluated at kr. khat is the direction of propagation and e0 is the polarization. kr is a Ntimes 3 float array. The output is a Ntimes 3 complex array represeinting the electric field. This plane wave is defined as:\n\nmathbfEleft(mathbfrright)=mathbfE_0e^imathbfkcdotmathbfr\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","text":"plane_wave_e_m(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes a simple plane with dimensionless input evaluated at kr. khat is the direction of propagation and e0 is the polarization. kr is a Ntimes 3 float array. The output is a Ntimes 6 complex array representing the electric and magnetic field. This plane wave is defined as:\n\nmathbfEleft(mathbfrright)=mathbfE_0e^imathbfkcdotmathbfr\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","text":"point_dipole_e(krf, krd, dip, e0_const=1)\n\nFunction that calculated the electromagnetic field emitted by a point dipole.\n\n#Arguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr_f where the field is calculated.\nkrd: 2D float array of size 1times 3 containing the dimentionless positions kvecr_d where source is located.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 3 with the desired dipole moment of the dipole.  \n\n#Outputs\n\ne_dipole: complex array with the electromagnetic field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","text":"point_dipole_e_m(krf, krd, dip, e0_const=1)\n\nFunction that calculated the electromagnetic field emitted by a point dipole.\n\n#Arguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimentionless positions kvecr_f where the field is calculated.\nkrd: 2D float array of size 1times 3 containing the dimentionless positions kvecr_d where source is located.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 6 with the desired dipole moment of the dipole.  \n\n#Outputs\n\ne_dipole: complex array with the electromagnetic field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gauss_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e","text":"gauss_beam_e(rf,k,bw0, maxe = Int(5e3))\n\nField distribution of a Gaussian beam that propagates along the z-axis and the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E -> Hz and Hz -> -E. \n\n#Arguments\n\nrf: 2D float array of size Ntimes 3 containing the positions where the field is calculated (N is the number of positions).\nk: scalar with the modulus wavevector.\nbw0: float with the beam waist radius.\nmaxe: maximum number of evaluations in the adapative integral (see Cubature for more details).\n\n#Outputs\n\neh_gauss: 2D complex array of size Ntimes 6 with the value of the field at every position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e","text":"ghermite_beam_e(rf,k,bw0,n,m,maxe=Int(5e3))\n\nField distribution of a Hermite-Gaussian beam that propagates along the z-axis and the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E -> Hz and Hz -> -E. \n\n#Arguments\n\nrf: 2D float array of size Ntimes 3 containing the positions where the field is calculated (N is the number of positions).\nk: scalar with the modulus wavevector.\nbw0: float with the beam waist radius.\nn: int with the order of the beam.\nm: int with the degree of the beam.\nmaxe: maximum number of evaluations in the adapative integral (see Cubature for more details).\n\n#Outputs\n\neh_hermite: 2D complex array of size Ntimes 6 with the value of the field at every position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e","text":"glaguerre_beam_e(rf,k,bw0,n,m,maxe=Int(5e3))\n\nField distribution of a Laguerre-Gaussian beam that propagates along the z-axis and the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E -> Hz and Hz -> -E. \n\n#Arguments\n\nrf: 2D float array of size Ntimes 3 containing the positions where the field is calculated (N is the number of positions).\nk: scalar with the modulus wavevector.\nbw0: float with the beam waist radius.\nn: non-negative int with the radial order of the beam.\nm: int with the azimuthal order of the beam.\nmaxe: maximum number of evaluations in the adapative integral (see Cubature for more details).\n\n#Outputs\n\neh_hermite: 2D complex array of size Ntimes 6 with the value of the field at every position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gauss_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e_m","text":"gauss_beam_e_m(rf,k,bw0, maxe = Int(5e3))\n\nField distribution of a Gaussian beam that propagates along the z-axis and the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E -> Hz and Hz -> -E. \n\n#Arguments\n\nrf: 2D float array of size Ntimes 3 containing the positions where the field is calculated (N is the number of positions).\nk: scalar with the modulus wavevector.\nbw0: float with the beam waist radius.\nmaxe: maximum number of evaluations in the adapative integral (see Cubature for more details).\n\n#Outputs\n\neh_gauss: 2D complex array of size Ntimes 6 with the value of the field at every position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e_m","text":"ghermite_beam_e_m(rf,k,bw0,n,m,maxe=Int(5e3))\n\nField distribution of a Hermite-Gaussian beam that propagates along the z-axis and the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E -> Hz and Hz -> -E. \n\n#Arguments\n\nrf: 2D float array of size Ntimes 3 containing the positions where the field is calculated (N is the number of positions).\nk: scalar with the modulus wavevector.\nbw0: float with the beam waist radius.\nn: int with the order of the beam.\nm: int with the degree of the beam.\nmaxe: maximum number of evaluations in the adapative integral (see Cubature for more details).\n\n#Outputs\n\neh_hermite: 2D complex array of size Ntimes 6 with the value of the field at every position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e_m","text":"glaguerre_beam_e_m(rf,k,bw0,n,m,maxe=Int(5e3))\n\nField distribution of a Laguerre-Gaussian beam that propagates along the z-axis and the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E -> Hz and Hz -> -E. \n\n#Arguments\n\nrf: 2D float array of size Ntimes 3 containing the positions where the field is calculated (N is the number of positions).\nk: scalar with the modulus wavevector.\nbw0: float with the beam waist radius.\nn: non-negative int with the radial order of the beam.\nm: int with the azimuthal order of the beam.\nmaxe: maximum number of evaluations in the adapative integral (see Cubature for more details).\n\n#Outputs\n\neh_hermite: 2D complex array of size Ntimes 6 with the value of the field at every position.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledElectricMagneticDipoles.jl","page":"Home","title":"CoupledElectricMagneticDipoles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome on the documentation website for the coupled electric and magnetic dipoles (CEMD), or discrete dipoles approximation (DDA) method implementation in Julia! On this website, you will find all the description of the functions implemented in this library. Please, read carefully the next sections in order to be ready to code with CoupledElectricMagneticDipoles.jl!","category":"page"},{"location":"#How-to-use-this-website","page":"Home","title":"How to use this website","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This website is divided in three parts. The first one is the theory tab, in which you will be able to find the derivations of all the formulas that are used in this software. The next tab is dedicated to the 7 submodules of the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DDACore: Contains the functions to solve the coupled dipoles system of equations.\nGreenTensors: Contains functions to compute the electric and magnetic or both green tensors.\nAlphas: Small library to compute the polarisabilities.\nGeometries: Small library to discretize some 3d objects or to generate some 3D random structures.\nMieCoeff: Contains functions to compute the Mie coefficients.\nPostProcessing: Small library used to compute the scattering, absorption and extinction cross sections, as well as the scattered field.\nInputFields: Small library with functions for input fields (plane waves,...).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the example tab gives three examples for the use of this library.","category":"page"},{"location":"#Installing-the-library","page":"Home","title":"Installing the library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the library is not yet in the big registery of the julia package manager, you have to download the CoupledElectricMagneticDipoles in local in order to use it. In order to be able to run it, please run in your julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add \"path to the library\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this, the package will be precompiled and the dependancies are going to be installed. Then, you will be able to import the library, by using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledElectricMagneticDipoles","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the library is installed and activated and despite the fact that everything is unit-tested during the installation of the library,we strongly recommand you to try to run one example to see if everything's works well.","category":"page"},{"location":"#About-the-Units","page":"Home","title":"About the Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the numerical methods used in the CEMD software are inputing and outputing only numbers (and not physical quantities), this is of the responsability of the user to use consistent system of units. That means that the same unit of length L should be used for positions (units of L), wavenumber (units of L⁻¹) and polarisability (units of L³).","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, this code is using two different system of units","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the only electric coupled dipole method.\nFor the electric and magnetic coupled dipoles method. In this case, a renormalized system of units desribed in the Theory part is used in order to simplify the computations. The functions with the _renorm suffix are then aimed to be used for the electric and magnetic coupled dipoles method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please then be aware of the type of","category":"page"},{"location":"#CPU-Parallel/GPU-running","page":"Home","title":"CPU Parallel/GPU running","text":"","category":"section"},{"location":"#Solvers","page":"Home","title":"Solvers","text":"","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Authors: Augustin Muster, Diego Romero Abujetas, Luis S. Froufe-Pérez.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contact email: augustin@must-r.com","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are open to any comments, ideas or questions about this software. Don't hesitate to write us, but please be aware that we are not guaranteeing support.","category":"page"},{"location":"miecoeff/#Mie-Coefficients","page":"MieCoeff","title":"Mie Coefficients","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"MieCoeff is a small modules to compute Mie Coefficients, mostly to use it to compute polarizabilities. It also contains some useful function to compute cross sections from the Mie theory. ","category":"page"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"Expressions are taken in Craig F. Bohren, Donald R. Huffman, Absorption and Scattering of Light by Small Particles (1998).","category":"page"},{"location":"miecoeff/#Functions-Documentation","page":"MieCoeff","title":"Functions Documentation","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_an(vac_knorm, a, eps, eps_h,n)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an-NTuple{5, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an","text":"mie_an(knorm, a, eps, eps_h, n)\n\nComputes the n-th mie coefficient a_n of a sphere of radius a with dielectric constant eps, in a medium with dielectric constant eps_h. vac_knorm is wavenumber in the medium.  Retruns a complex scalar.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_bn(vac_knorm, a, eps, eps_h, n)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn-NTuple{5, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn","text":"mie_bn(knorm, a, eps, eps_h, n)\n\nComputes the n-th mie coefficient b_n of a sphere of radius a with dielectric constant eps, in a medium with dielectric constant eps_h. vac_knorm is wavenumber in the medium. Returns a complex scalar. \n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_scattering_cross_section(knorm,a,eps,eps_h;cutoff=50)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_scattering_cross_section-NTuple{4, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_scattering_cross_section","text":"mie_scattering_cross_section(knorm,a,eps,eps_h;cutoff=50)\n\nComputes the scattering cross section C_sca of a sphere of radius a with dielectric constant eps in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium. For this, we use:\n\nC_sca =frac2pik^2sum^infty_n=1left(2n+1right)left(a_n^2+b_n^2right)\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 50).\n\nReturns a float with units of surface.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_extinction_cross_section(knorm,a,eps,eps_h;cutoff=50)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction_cross_section-NTuple{4, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction_cross_section","text":"mie_extinction_cross_section(knorm,a,eps,eps_h;cutoff=50)\n\nComputes the extinction cross section C_sca of a sphere of radius a with dielectric constant eps in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium. For this, we use:\n\nC_ext =frac2pik^2sum^infty_n=1left(2n+1right)Releft(a_n+b_nright)\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 50).\n\nReturns a float with units of surface.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_absorption_cross_section(knorm,a,eps,eps_h;cutoff=50)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_absorption_cross_section-NTuple{4, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_absorption_cross_section","text":"mie_absorption_cross_section(knorm,a,eps,eps_h;cutoff=50)\n\nComputes the extinction cross section C_sca of a sphere of radius a with dielectric constant eps in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium. For this, we use:\n\nC_abs =C_ext-C_sca\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 50).\n\nReturns a float with units of surface.\n\n\n\n\n\n","category":"method"}]
}
